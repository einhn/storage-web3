// backend/src/jobs/monthlyBilling.ts
import { prisma } from "../lib/prisma";
import { commitMonthlyUsage as commitOnchain } from "../web3/usageBillingClient";
import * as crypto from "crypto";

// "매월 2일 10:00"에 실행된다고 가정하고,
// 전달 2일 10:01 ~ 이번달 2일 10:00 구간을 "이전달 정산"으로 본다.
//
// 예: now = 2025-12-02 10:00 KST
//  => start = 2025-11-02 10:01 KST
//  => end   = 2025-12-02 10:00 KST
//  => billingYear = 2025, billingMonth = 11
function getRollingMonthRange(now: Date) {
  // now 기준으로 "앵커(anchor) 월"을 결정
  // - day > 2: 이번달 2일 10시를 end 로 사용
  // - day = 2 & time >= 10: 이번달 2일 10시를 end 로 사용
  // - 그보다 이르면 → 한 달 전을 end 기준으로 사용 (지연 실행 대비)
  const kstNow = new Date(now.toLocaleString("en-US", { timeZone: "Asia/Seoul" }));

  const year = kstNow.getFullYear();
  const month = kstNow.getMonth() + 1; // 1~12
  const day = kstNow.getDate();
  const hour = kstNow.getHours();
  const minute = kstNow.getMinutes();

  let anchorYear = year;
  let anchorMonth = month;

  const isOnOrAfterAnchorTime =
    day > 2 ||
    (day === 2 && (hour > 10 || (hour === 10 && minute >= 0)));

  if (!isOnOrAfterAnchorTime) {
    // 아직 이번달 2일 10:00 이전이면 → 한 달 전을 기준으로 본다
    if (month === 1) {
      anchorYear = year - 1;
      anchorMonth = 12;
    } else {
      anchorMonth = month - 1;
    }
  }

  // end: anchorYear-anchorMonth-02 10:00 KST
  const end = new Date(
    `${anchorYear}-${String(anchorMonth).padStart(2, "0")}-02T10:00:00+09:00`,
  );

  // start: end 기준 한 달 전의 2일 10:01 KST
  let startYear = anchorYear;
  let startMonth = anchorMonth - 1;
  if (startMonth === 0) {
    startMonth = 12;
    startYear -= 1;
  }

  const start = new Date(
    `${startYear}-${String(startMonth).padStart(2, "0")}-02T10:01:00+09:00`,
  );

  // 청구는 start 기준 한 달 단위
  const billingYear = startYear;
  const billingMonth = startMonth;

  return { billingYear, billingMonth, start, end };
}

async function main() {
  const now = new Date();
  const { billingYear, billingMonth, start, end } = getRollingMonthRange(now);

  console.log(
    `[monthlyBilling] billing ${billingYear}-${billingMonth}, range: ${start.toISOString()} ~ ${end.toISOString()}`,
  );

  // 1) 이 기간에 업로드가 있는 "모든" 유저 (지갑 여부와 상관없이)
  const users = await prisma.user.findMany({
    where: {
      userFiles: {
        some: {
          uploadedAt: {
            gte: start,
            lt: end,
          },
        },
      },
    },
    include: {
      userFiles: {
        where: {
          uploadedAt: {
            gte: start,
            lt: end,
          },
        },
        include: {
          file: true,
        },
      },
    },
  });

  console.log("[DEBUG] billing target users =", users.length);
  console.log(
    "[DEBUG] billing userIds =",
    users.map((u) => u.id.toString()),
  );

  if (users.length === 0) {
    console.log("[monthlyBilling] no users to bill in range");
    return;
  }

  for (const user of users) {
    try {
      // 2) 해당 유저의 기간 내 업로드 용량 합산
      let totalBytesBig = 0n;
      for (const uf of user.userFiles) {
        totalBytesBig += uf.file.size; // BigInt
      }

      console.log(
        `[DEBUG] userId=${user.id.toString()}, wallet=${user.walletAddress ?? "NULL"}, files=${user.userFiles.length}, bytes=${totalBytesBig.toString()}`,
      );

      // 예시 요금 정책: 1 byte = 1 wei
      const billedAmountBig = totalBytesBig;
      const billedAmountStr = billedAmountBig.toString();

      const walletAddress = user.walletAddress ?? null;

      // snapshotHash는 지갑 주소 없어도 생성 가능 (off-chain 기준용)
      const hashSource = `${walletAddress ?? "no-wallet"}-${billingYear}-${billingMonth}-${totalBytesBig.toString()}-${billedAmountStr}`;

      const snapshotHash =
        "0x" +
        crypto.createHash("sha256").update(hashSource).digest("hex");

      // 3) UsageSnapshot upsert (지갑 없어도 모두 스냅샷 생성)
      let snapshot = await prisma.usageSnapshot.upsert({
        where: {
          userId_year_month: {
            userId: user.id,
            year: billingYear,
            month: billingMonth,
          },
        },
        update: {
          totalBytes: totalBytesBig,
          billedAmount: billedAmountStr,
          snapshotHash,
        },
        create: {
          userId: user.id,
          year: billingYear,
          month: billingMonth,
          totalBytes: totalBytesBig,
          billedAmount: billedAmountStr,
          snapshotHash,
        },
      });

      // 4) 지갑 없으면 온체인 커밋은 스킵 (스냅샷만 유지)
      if (!walletAddress) {
        console.warn(
          `[monthlyBilling] userId=${user.id.toString()} has no walletAddress; snapshot only, no on-chain commit`,
        );
        continue;
      }

      // 5) 지갑 있고 용량이 0이면 온체인 커밋 스킵해도 됨 (옵션)
      if (totalBytesBig === 0n) {
        console.log(
          `[monthlyBilling] userId=${user.id.toString()} has 0 bytes; skipping on-chain commit (snapshot exists)`,
        );
        continue;
      }

      // 6) 온체인 commitMonthlyUsage 호출
      const receipt = await commitOnchain({
        user: walletAddress,
        year: billingYear,
        month: billingMonth,
        totalBytes: totalBytesBig,
        billedAmount: billedAmountBig,
        snapshotHash,
      });

      const txHash = receipt.hash;
      const blockNumber = receipt.blockNumber ?? null;

      snapshot = await prisma.usageSnapshot.update({
        where: { id: snapshot.id },
        data: {
          commitTxHash: txHash,
          commitBlock:
            blockNumber !== null ? BigInt(blockNumber) : null,
        },
      });

      console.log(
        `[monthlyBilling] user=${walletAddress}, bytes=${totalBytesBig.toString()}, tx=${txHash}`,
      );
    } catch (e: any) {
      console.error(
        `[monthlyBilling] userId=${user.id.toString()} error:`,
        e?.message ?? e,
      );
    }
  }

  console.log("[monthlyBilling] done");
}

main()
  .catch((e) => {
    console.error("[monthlyBilling] fatal:", e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });